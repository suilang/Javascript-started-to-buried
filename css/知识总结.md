## 标准的CSS盒子模型及其和低版本的IE盒子模型的区别？

标准盒模型(`content-box`)：width = 内容宽度（content） + border + padding + margin

低版本IE盒子模型(`border-box`)： width = 内容宽度（content + border + padding）+ margin

区别： 标准盒子模型盒子的`height`和`width`是`content`的宽高，而IE盒子模型盒子的宽高则包括`content+padding+border`部分。

## CSS优先级算法如何计算？

`！important  >   内联样式   >   id   >   class   >   标签   >   通配符   >   继承   >   默认`

#### **权重计算**

把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。

4个等级的定义如下：

> 假设第零等：!important 权值10000
> 第一等：代表内联样式，如: style=””，权值为1000。
> 第二等：代表ID选择器，如：#content，权值为0100。
> 第三等：代表类，伪类和属性选择器，如.content，权值为0010。
> 第四等：代表标签选择器和伪元素选择器，如div p，权值为0001。
> 第五等：通用选择器（*），子选择器（>），相邻同胞选择器（+），权值为0000
示例如下：
```
**注意** 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0
#header #left ul li .first a {...}
  100.   100  1  1.  10    1
---> sum 0213
```
1. 权重相同，写在后面的会覆盖前面的
2. 权重相同，一个在写在外部样式中`link`引入，另一个在内部样式`style`引入，引入顺序后面的覆盖前面的
3. 内联样式的权重为1,0,0,0，10个id选择器的权重也为0,10,0,0，内联样式优先级高


## 如何居中div？
> ps: 选中下列样例可在控制台直接调试，纯手工打造，作者诚意很足的

使用下列样式：  
####  1、margin: 0 auto;  
要求目标元素宽度固定，并且与父元素左右margin有空余。
> 适用于父元素内有多个块级元素上下排列的情况

```html
<div class="container">
  this is inner text
  <div classs="ele2">
      this is another block element
  </div>
</div>
```
```css
.container{
  width: 300px;
  border: 1px solid grey;
  text-align: center;
}
.ele2{
  border: 1px solid grey;
  width: 200px;
  margin:0 auto;
}
```
<div class="container" style="width: 300px;
  border: 1px solid grey;
  text-align: center;">
  this is inner text
  <div classs="ele2" style="border: 1px solid grey;
  width: 200px;margin: 0 auto">
      this is another block element
  </div>
</div>

> 如果上下的margin设置了auto，其计算值为0

#### 2、absolute + transform

transform设置百分比参数是相对于自身尺寸的
```html
<div class="container">
   this is inner text
  <div class="ele1">
    this is a block element
  </div>
</div>
```
```css
.container{
    height: 100px;
    width: 200px;
    position: relative;
    border: 1px solid grey;
  	text-align: center;
}
.ele1{
    position: absolute;
    left: 50%;
    transform: translateX(-50%);  
    width: 100px; // 此处可以不设置，默认为父元素一半宽度
    border: 1px solid #888;
}
```
<div class="container" style="height: 100px;
    width: 200px;
    position: relative;
    border: 1px solid grey;
  	text-align: center;">
   this is inner text
  <div class="ele1" style="position: absolute;
    left: 50%;
    transform: translateX(-50%);  
    width: 100px;
    border: 1px solid #888;">
    this is a block element
  </div>
</div>

> ele1可以不设定width的值，此时ele1的宽度会被计算为 `父元素的一半 - 左右边框的宽度`

#### 3、 absolute + margin

margin设置百分比参数是相对于父元素的，所以，此方法需要子元素**固定宽度**，并且值设为自身宽度的一半；  

html代码同上，替换 `ele1` 元素样式中  `transform: translateX(-50%)` 为 `margin-left: -50px;` 

```css
.ele1{
    position: absolute;
    left: 50%;
    margin-left: -50px; // 负值，设为元素自身宽度的一半
    width: 100px; // 此处必须设置
    border: 1px solid #888;
}
```
<div class="container" style="height: 100px;
    width: 200px;
    position: relative;
    border: 1px solid grey;
  	text-align: center;">
   this is inner text
  <div class="ele1" style="position: absolute;
    left: 50%;
    margin-left: -50px;
    width: 100px;
    border: 1px solid #888;">
    this is a block element
  </div>
</div>
#### 4、 flex
    这个不用叙述了吧  
#### 5、 absolute + margin: auto
    适用于垂直居中

更多布局请移步[可食用的「css布局干货」 | 水平、垂直、多列](https://juejin.im/post/5ec53111f265da76e97d2c55)，  
条理清晰的列举了水平及垂直居中，手打示例，可在页面调试

### display有哪些值？他们的作用是什么？

| 值                 | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| none               | 使用后元素将不会显示                                         |
| block              | 使用后元素将变为块级元素显示，元素前后带有换行符             |
| inline             | display默认值。使用后原色变为行内元素显示，前后无换行符      |
| list-item          | 使用后元素作为列表显示                                       |
| run-in             | 使用后元素会根据上下文作为块级元素或行内元素显示             |
| table              | 使用后将作为块级表格来显示（类似`<table>`），前后带有换行符  |
| inline-table       | 使用后元素将作为内联表格显示（类似`<table>`），前后没有换行符 |
| table-row-group    | 元素将作为一个或多个行的分组来显示（类似`<tbody>`）          |
| table-header-group | 元素将作为一个或多个行的分组来表示（类似`<thead>`）          |
| table-footer-group | 元素将作为一个或多个行分组显示（类似`<tfoot>`）              |
| table-row          | 元素将作为一个表格行显示（类似`<tr>`）                       |
| table-column-group | 元素将作为一个或多个列的分组显示（类似`<colgroup>`）         |
| table-column       | 元素将作为一个单元格列显示（类似`<col>`）                    |
| table-cell         | 元素将作为一个表格单元格显示（类似`<td>和<th>`）             |
| table-caption      | 元素将作为一个表格标题显示（类似`<caption>`）                |
| inherit            | 规定应该从父元素集成display属性的值                          |

### position不同的值的定位原点及其特性？

`relative`（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置，在原本文档流位置占据一定空间；

`absolute`（绝对定位）：生成绝对定位的元素，定位原点是最近的position`设置为`absolute`或者`relative`的父元素的左上角。

`fixed` （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位，元素会被移出正常文档流，并不为元素预留空间。

`static`：默认值。没有定位，元素出现在正常的流中（忽略 `top`, `bottom`, `left`, `right`、`z-index` 声明）。

`inherit`：从父元素继承 `position` 属性的值。

`sticky`：元素根据正常文档流进行定位，可以被认为是相对定位和固定定位的混合。当元素在屏幕或滚动元素显示区域时，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。可用来做吸顶特效，详见[css position属性及其sticky属性值的特性](https://juejin.im/post/5ebd3001f265da7bcd5c62da)

### 如何用纯CSS创建一个三角形
> ps: 选中下列样例可在控制台直接调试，纯手工打造，作者诚意很足的

块级元素宽高设为0，仅设置某一条边的颜色，另外三条边颜色设定为（transparent）

```html
<div class="container">
  <div class="triangle-top"></div>
   <div class="triangle-left"></div>
   <div class="triangle-right"></div>
   <div class="triangle-bottom"></div>
</div>
```

```css
.container{
  display: flex;
  justify-content: space-between;
  width: 400px;
}
.container div{
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent;
}
.container .triangle-top {
    border-bottom-color: orange; 
}
.container .triangle-left {
    border-right-color: orange; 
}
.container .triangle-right {
    border-left-color: orange; 
}
.container .triangle-bottom {
    border-top-color: orange; 
}
```
<div class="container" style=" display: flex;
  justify-content: space-between;
  width: 400px;">
  <div class="triangle-top" style=" width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent;
  border-bottom-color: orange; "></div>
   <div class="triangle-left" style=" width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent;
  border-right-color: orange; "></div>
   <div class="triangle-right" style=" width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent;
  border-left-color: orange; "></div>
   <div class="triangle-bottom" style=" width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent;
  border-top-color: orange; "></div>
</div>

> 记得使用相对定位居中箭头

## 浮动原理及什么时候需要清除浮动？清除浮动的方式？

### 什么是浮动
元素加了浮动后，会脱离文档流，提升了半层层级，向着指定方向移动，直到遇到父元素的边界或另一个浮动元素停止
### 什么是层级
如果将整个元素看做一层，则下半层是元素本身（背景样式等），上半层是元素中的内容

**举例**

```html
<div class="container">
  <div class="box1">box1</div>
   <div class="box2">box2</div>
   <div class="box3">box3</div>
</div>
```
```css
.container{
 width: 40px;
 border: 1px solid black;
}
.container div{
  width: 100%;
  height: 30px;
}
.box1 {
  background: yellow;
}
.box2 {
    background: orange; 
}
.box3 {
     background: pink; 
}
```
三个盒子都没有浮动时

<div class="container" style="width: 40px;border: 1px solid black;">
  <div class="box1" style=" width: 100%;
  height: 30px; background: yellow;">box1</div>
   <div class="box2" style=" width: 100%;
  height: 30px; background: orange;">box2</div>
   <div class="box3" style=" width: 100%;
  height: 30px; background: pink;">box3</div>
</div>

当给box2添加float:left时，三个盒子的排列变成
<div class="container" style="width: 40px;border: 1px solid black;">
  <div class="box1" style=" width: 100%;
  height: 30px; background: yellow;">box1</div>
   <div class="box2" style=" width: 100%;
  height: 30px; background: orange;float: left">box2</div>
   <div class="box3" style=" width: 100%;
  height: 30px; background: pink;">box3</div>
</div>


此时由于box2浮动脱离了文档流，box3上移，被box2遮挡了。但此时box3盒子里的文字box3并没有上移！！！

**小知识**
1. 浮动元素之间是漂浮着，并不会形成一个流。浮动元素总是要保证自己的顶部与上一个标准流中的元素（未浮动元素）的底部对齐。
2. position：absolute和float会隐式地改变display类型，除display:none外，只要设置了position：absolute或float，都会让元素以display:inline-block的方式显示，可以设置长宽

浮动会带来的问题：

1.影响兄弟元素的位置

2.使父元素产生高度塌陷

### 清除浮动造成的缺陷的方式：

- 父级盒子定义高度（height）;
- 最后一个浮动元素后面加一个div空标签，并且添加样式clear: both;
- 包含浮动元素的父级标签添加样式overflow为hidden/both;
- 父级div定义zoom;
### 清除浮动的实质

1. 利用css的clear属性，加clear:both
2. 触发浮动元素父元素的BFC，使该父元素可以包含浮动元素

## CSS预处理器/后处理器是什么？为什么要使用它们？

- 预处理器，
    如：less，sass，stylus,用来预编译sass或者less，增加了css代码的复用性，还有层级，mixin， 变量，循环， 函数等，对编写以及开发UI组件都极为方便。详情移步[Sass.vs.Less | 简介与比较](https://juejin.im/post/5eccf4ed51882543152cf0fc)

- 后处理器
    是对 CSS 进行处理，并最终生成 CSS 的 预处理器，它属于广义上的 CSS 预处理器。
我们很久以前就在用 CSS 后处理器 了，最典型的例子是 CSS 压缩工具（如 clean-css），只不过以前没单独拿出来说过。  
还有最近比较火的 Autoprefixer，以 Can I Use 上的 浏览器支持数据 为基础，自动处理兼容性问题。

使用原因：
- 结构清晰， 便于扩展
- 可以很方便的屏蔽浏览器私有语法的差异
- 可以轻松实现多重继承

## ::before 和 :after中双冒号和单冒号有什么区别？

在 CSS 中伪类一直用单冒号 : 表示，如 :hover, :active 等

伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after，后来在CSS3中修订，为了区分伪元素和伪类，伪元素改用用 :: 表示，如 ::before 和 ::after。

> 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素。

想让插入的内容出现在其元素内容前，使用::before，否者，使用::after；

在代码顺序上，::after生成的内容也比::before生成的内容靠后。

如果按堆栈视角，::after生成的内容会在::before生成的内容之上

## 伪元素和伪类的区别

css引入伪类和伪元素概念是为了格式化文档树以外的信息。
- 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

- 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

**css伪类**

| 选择器 | 示例    | 示例说明  |
| :------------------------- | :------------- | :----------- |
| [:link]    | a:link     | 选择所有未访问链接      |
| [:visited]  | a:visited      | 选择所有访问过的链接     |
| [:active]     | a:active       | 选择正在活动链接       |
| [:hover]       | a:hover        | 把鼠标放在链接上的状态     |
| [:focus]       | input:focus    | 选择元素输入后具有焦点       |

**css伪元素**

| 选择器 | 示例    | 示例说明  |
| :------------------------- | :------------- | :----------- |
| [:first-letter] | p:first-letter | 选择每个<p> 元素的第一个字母    |
| [:first-line]| p:first-line   | 选择每个<p> 元素的第一行         |
| [:first-child] | p:first-child  | 选择器匹配属于任意元素的第一个子元素的 <p> 元素 |
| [:before] | p:before       | 在每个<p>元素之前插入内容                       |
| [:after]  | p:after        | 在每个<p>元素之后插入内容                       |
| [:lang(*language*)] | p:lang(it)     | 为<p>元素的lang属性选择一个开始值               |

## 手动写动画最小时间间隔是多久

多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。

##  rgba() 和 opacity 的透明效果有什么不同？

- `opacity` 作用于元素以及元素内的所有内容（包括文字）的透明度；
- `rgba()`只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；



## css 属性 content 有什么作用？

content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。

**扩展：如何通过css content属性实现css计数器？**

css计数器是通过设置counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合after / before 伪类实现。

## px、em、rem有什么区别？

- `px`相对于显示器屏幕分辨率。

    **PX特点**

    -  IE无法调整那些使用px作为单位的字体大小；
    -  国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；
    -  Firefox能够调整px和em，rem。

- em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。

    **EM特点**

    - em的值并不是固定的；
    - em会继承父级元素的字体大小。

注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。

- rem是CSS3新增的一个相对单位（root em，根em），这个单位与em区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。

目前，除了IE8及更早版本外，所有浏览器均已支持rem。

## 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？

1. 使用`calc`
```css
.div1{
	height: 100px;
}
.div2 { 
	height: calc(100%-100px); 
}
```
2. 绝对定位
```css
.container{
	position: relative;
}
.div1{
	height: 100px;
}
.div2 { 
	position: absolute;
	top: 100px;
  bottom: 0;
}
```
3. `flex`布局
```css
.container { 
  display:flex; 
  flex-direction:column; 
} 
.div1{
	height: 100px;
}
.div2 { 
	flex:1; 
}
```

## transition、transform和animation的区别

**Transform:**

transform属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。transform的主要用途是用来做元素的特殊变形，它定义了元素静态样式中实现变形、旋转、缩放、移位及透视等功能。

**Transition**

transition属性是一个简单的动画属性，可以说它是animation的简化版本，是给普通做简单网页特效用的。

比如你有如下两个样式：
```
.position{
    left:100px;
    top:100px;
}
.position1{
    -webkit-transition:left 0.5s ease-out;
    left:500px;
    top:500px;
}
```

元素的`class`类为`position`。当你将其`classList` 增加 `position1` 或者替换`position` 为`position1`的时候，元素的属性变化，触发webkit-transition，以指定属性变化前的值为起始值，变化后的属性为结束值，执行动画效果。这是一个简单的两点变化过程，大大简化了`animation`属性的复杂程度。

其中`position1`的`transition`的属性的意思说：当你的`left`属性发生变化的时候，执行动画效果（仅仅基于left的属性变化，其他的属性不会加入到动画变化里面去）；

> 在transtion属性里面指定响应属性为all，可以响应并执行元素所有属性的变化动画（能做动画的属性）。


**Animation:**

在官方的Introduction上介绍这个属性是transition属性的扩展。但是这个简单的介绍里面包含了不简单的东西：keyframes。

看一个简单的 keyframes 的示例：
```css
@keyframes 'wobble'{
  0%{
   left:100px
}
   30%{
   left:300px;
}
  100%{
   left:500px;
}
}
.animate{
left:100px;
   -webkit-animation:wobble 0.5s ease-out;
   -webkit-animation-fill-mode:backwards;
}
```
上面这个代码展示了一个keyframes ‘wobble’，其中 0％ 代表在变化中不同时间点的属性值，你可以较精确的控制动画变化中任何一个时间点的属性效果。而animation则根据这个keyframes提供的属性变化方式去计算元素动画当中的属性。

它本身被用来替代一些纯粹表现的javascript代码而实现动画,可以通过keyframe显式控制当前帧的属性值。
> animation-fill-mode，这个属性标示是以(from/0%)指定的样式 还是以(to/100%)指定的样式为动画完成之后的样式。这个很方便我们控制动画的结尾样式，保证动画的整体连贯。

## 对 line-height 的理解？

line-height指的是一行字的高度，包含了字间距，实际上是下一行基线到上一行基线的距离。

如果一个标签没有定义height属性(包括百分比高度)，那么其最终表现的高度一定是由line-height起作用

换种理解方式，如果一个有文字的div，不设置高度，并将其行高设置0，div将不会被撑开。
```html
<div class="container">
  <div class="ele">
    this is inner text
  </div>
  <div class="ele1">
    this is inner text
  </div>
</div>
```
```css
.container{
    width: 220px;
    height:100px;
    border: 1px solid grey;
}
div{
   margin-top: 20px;
   border: 1px solid grey;
}
.ele{
 line-height:0;
}
```
<div class="container" style=" width: 220px;
    height:100px;
    border: 1px solid grey;">
  <div class="ele" style="margin-top: 20px;
   border: 1px solid grey;line-height:0;">
    this is inner text
  </div>
  <div class="ele1" style="margin-top: 20px;
   border: 1px solid grey;">
    this is inner text
  </div>
</div>
详情可移步[可食用的「css布局干货」,纯Html示例，可调试 | 水平、垂直、多列](https://juejin.im/post/5ec53111f265da76e97d2c55#heading-9) 中`line-height` 部分

## CSS 外边距(margin)重叠及防止方法

相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。

折叠结果遵循下列计算原则：

两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；
两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；
两个外边距一正一负时，折叠结果是两者的相加的和；

什么情况下不会产生外边距重叠？

1. 水平边距永远不会重合。
2. 相邻的盒模型中，如果其中的一个是浮动的（float），垂直margin不会重叠，并且浮动的盒模型和它的子元素之间也是这样。
3. 设置了overflow属性的元素和它的子元素之间的margin不被重叠（overflow取值为visible除外）。
4. 设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，并且和他们的子元素之间也是一样。

其实边距重叠主要是由于重叠的两个元素处于同一个BFC下。通过某些属性使元素生成新的BFC上下文即可解决



### 什么是BFC？怎么触发BFC？有什么用？

BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

#### BFC的布局约束规则

- 内部的Box会在垂直方向，一个接一个地放置。

- Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。

- 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。即BFC中子元素不会超出他的包含块。

- BFC的区域不会与float box重叠。

- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

- 计算BFC的高度时，浮动元素也参与计算。

#### BFC触发方式

1. 根元素，即HTML标签
2. 浮动元素：float值为left、right
3. overflow值不为 visible，为 auto、scroll、hidden
4. display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
5. 定位元素：position值为 absolute、fixed
   **注意：**
   `display: table`也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。

### BFC作用

BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。

1. 同一个 BFC 下外边距会发生折叠

2. BFC 可以包含浮动的元素（清除浮动
  
3. BFC 可以阻止元素被浮动元素覆盖

[BFC示例及详细讲解](https://juejin.im/post/5ef834a2e51d4534791d3ade)

### display: none; 与 visibility: hidden; 有什么区别？
两者都会使元素变得不可见。

|  区别    | 描述 |
| :-----: | :--: |
| 文档流 |  display: none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见；|
| 继承性 | display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式；|
| 渲染影响 |  修改元素的display属性使元素消失或显示通常会造成回流。修改visibility属性只会导致重绘 |
| 读屏器 | 无法读取 `display: none`的元素内容；会读取visibility: hidden元素内容；|


## 隐藏元素的方法有哪几种？

- `visibility: hidden`: 隐藏某个元素，但是元素占用的空间任然存在；
- `opacity: 0`: 使一个元素完全透明；
- `position: absolute + 一个很大的 left 负值定位`: 使元素定位在可见区域之外；
- `display: none`:  元素不可见，并且不再占用文档的空间；
- `transform: scale(0)`:  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；
- `<div hidden="hidden">`:  HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态；
- `height: 0`:  将元素高度设为 0 ，并消除边框，有时需同步设置`overflow: hidden`；
- `filter: blur(0)`:  CSS3属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失;

### li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格。换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。

解决办法：
1. 将< li>代码全部写在一排
2. 将`ul`字符尺寸直接设为0，重设`li`的字符尺寸
3. 将`ul`的字符间隔设置为-5px，重设`li`的字符尺寸
```css
.wrap ul{letter-spacing: -5px;}
.wrap ul li{letter-spacing: normal;}
```
4. 设置`li`的属性`float：left`；



















参考文档：

1. [CSS优先级及其计算方法](https://blog.csdn.net/xiaojinguniang/article/details/82869841)
2. [css篇--100道近两万字帮你巩固css知识点](https://juejin.im/post/5ee0cf335188254ec9505381?utm_source=gold_browser_extension)
3. [浮动float原理及清除浮动](https://www.cnblogs.com/Danyqueen/p/10757712.html)