# 回流与重绘

回流与重绘，会影响页面性能，每次这两个都会被同时提及，关系就好像KFC边上一定会有MC一样亲密的让人摸不到头脑。

要理解回流与重绘，首先要明白浏览器请求回来之后发生了什么

### 浏览器的渲染过程 <a id="item-1"></a>

![](../.gitbook/assets/image%20%283%29.png)

在页面加载时，浏览器渲染过程如下：

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树\(Render Tree\)
3. Layout\(回流\):根据生成的渲染树，进行回流\(Layout\)，得到节点的几何信息（位置，大小）
4. Painting\(重绘\):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层）

为了构建渲染树，浏览器主要完成了以下工作：

1. 从DOM树的根节点开始遍历每个可见节点。
2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
3. 根据每个可见节点以及其对应的样式，组合生成渲染树。

渲染树中只会包含可见节点。不可见节点包括：

* 一些不会渲染输出的节点，比如script、meta、link等。
* 一些通过css进行隐藏的节点。如display:none。

> 注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。

> 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算

### 回流

通过构造渲染树，将可见DOM节点以及它对应的样式结合起来，这时候需要计算它们在设备视口\(viewport\)内的确切位置和大小，这个计算的阶段就是回流。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。

### 重绘

通过构造渲染树和回流阶段，我们确定了可见节点，以及可见节点的样式和具体的几何信息\(位置、大小\)，将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

### 何时发生回流重绘 <a id="item-2"></a>

当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器将重新渲染部分或全部文档，这时发生的就是回流。

会导致回流的操作：

* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变（包括外边距、内边框、边框大小、高度和宽度等）
* 元素内容变化（文字数量或图片大小，比如用户在input框中输入文字等等）
* 元素字体大小变化
* 添加或者删除**可见**的`DOM`元素
* 激活`CSS`伪类（例如：`:hover）`
* 查询某些属性或调用某些方法

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

> **回流一定会触发重绘，而重绘不一定会回流**

### 性能与优化

回流比重绘的代价要高，至于具体的资源开销跟render树有多少节点需要重新构建有关。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。

大多数浏览器都会通过队列化修改并批量执行来优化重排过程。：

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：

* offsetTop、offsetLeft、offsetWidth、offsetHeight
* scrollTop、scrollLeft、scrollWidth、scrollHeight
* clientTop、clientLeft、clientWidth、clientHeight
* getComputedStyle\(\)
* getBoundingClientRect

> 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

### 手动优化

1. 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并通过更改元素`class`属性来应用样式。

   > 通过style属性设置样式导致回流。避免设置多级内联样式，因为每个都会造成回流，样式应该合并在一个外部类，这样当该元素的class属性可被操控时仅会产生一个reflow。

2. 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。

   > DocumentFragment 节点不属于文档树，在把它插入文档节点之前，随便给他增删节点都不会引起回流
   >
   > 使用cloneNode和replaceChild有类似的效果

3. 先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
4. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
5. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
6. 避免使用`CSS`表达式（例如：`calc()`）
7. 避免使用table布局

   table是个和罕见的可以影响在它们之前已经进入的DOM元素的显示的元素。即使一些小的变化将导致表格\(table\)中的所有其他节点回流。

8. css3硬件加速（GPU加速）

   > **使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘**




以上内容参考了下面的资料，如有雷同，那很正常。。\(这句话真不错～\)

### 参考文档：

1. [**回流（reflow）与重绘（repaint）**](https://www.cnblogs.com/dujingjie/p/5784890.html)
2. [**你真的了解回流和重绘吗**](https://segmentfault.com/a/1190000017329980)
3. [**浏览器的回流与重绘 \(Reflow & Repaint\)**](https://juejin.im/post/5a9923e9518825558251c96a)
4. [**回流与重绘：CSS性能让JavaScript变慢？**](https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/)

