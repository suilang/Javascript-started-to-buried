# LocalStorage

`localStorage` 是一个 Web API，用于在浏览器中存储键值对数据。这些数据会一直保存在用户的浏览器中，即使用户关闭浏览器或电脑，localStorage 中的数据也不会丢失，直到被清除。它提供了一种简单的方式来存储少量的数据，比如用户的偏好设置或者应用程序的状态。`localStorage` 中的数据可以通过 `JavaScript` 存取，并且在同一个域名下的所有页面都可以访问到这些数据。

# localStorage 是同步还是异步的？

首先明确一点，`localStorage`是同步的。

当你通过 `JavaScript` 访问 `localStorage` 时，浏览器会从硬盘中读取数据或向硬盘写入数据。然而，在读写操作期间，数据可能会被暂时存放在内存中，以提高处理速度。但主要的特点是它的持久性，以及它不依赖于会话的持续性。

## io 读取不都是异步的吗？

硬盘确实是一个 IO 设备，而大部分与硬盘相关的操作系统级 IO 操作确实是异步进行的，以避免阻塞进程，但这不代表着高级语言内部不能封装同步的调用方法。例如`nodejs`有同步读取文件的 API 接口。你可以使用`fs.readFileSync`方法来同步读取文件。这个方法会阻塞程序的执行直到文件读取完成。

js 代码在访问  `localStorage`  时，浏览器提供的 API 接口通常会处于 js 执行线程上下文中直接调用。这意味着尽管硬盘是 IO 设备，当一个 js 执行流程访问  `localStorage`  时，它将同步地等待数据读取或写入完成，该过程中 js 执行线程**会阻塞**。

这种同步 API 设计意味着开发者在操作  `localStorage`  时不需要考虑回调函数或者`Promise`等异步处理模式，可以按照同步代码的方式来编写。不过，这也意味着如果涉及较多数据的读写操作时，可能对性能产生负面影响，特别是在主线程上，因为它会阻塞 UI 的更新和其他 js 的执行。

## 完整操作流程

`localStorage`  实现同步存储的方式就是阻塞 `JavaScript` 的执行，直到数据的读取或者写入操作完成。这种同步操作的实现可以简单概述如下：

1. **js 线程调用:** 当 `JavaScript` 代码执行一个  `localStorage`  的操作，比如  `localStorage.getItem('key')`  或  `localStorage.setItem('key', 'value')`，这个调用发生在 js 的单个线程上。
2. **浏览器引擎处理:** 浏览器的 js 引擎接收到调用请求后，会向浏览器的存储子系统发出同步 IO 请求。此时 js 引擎等待 IO 操作的完成。
3. **操作完成返回:** 一旦 IO 操作完成，数据要么被写入硬盘，要么被从硬盘读取出来，浏览器存储子系统会将结果返回给 js 引擎。浏览器存储子系统对硬盘执行实际的存储或检索操作。尽管操作系统层面可能对文件访问进行缓存或优化，但从浏览器的角度看，它会进行一个同步的文件系统操作，直到这个操作返回结果。
4. **JavaScript 线程继续执行:** js 引擎在接收到操作完成的信号后，才会继续执行下一条 js 代码。

# 缓存满了再写入会怎样

当浏览器的`localStorage`存储空间已满时，继续尝试写入数据会导致存储失败。浏览器通常会抛出一个错误，表明无法再存储更多数据。为了解决这个问题，可以尝试清除一些旧数据或者使用其他存储方式，比如`IndexedDB`。

## localStorage 限制容量都是因为同步会阻塞的原因吗？

1. **资源公平分享：**同一用户可能会访问大量不同的网站，如果没有限制，随着时间的积累，每个网站可能会消耗大量的本地存储资源。这样会导致本地存储空间被少数几个站点占用，影响到用户访问其他网页的体验。限制大小可以确保所有网站都有公平的存储机会。
2. 防止滥用：如果没有存储限制，网站可能会滥用  `localStorage`，存储大量数据在用户的设备上，这可能导致设备存储空间迅速耗尽，也可能侵犯用户的隐私。
3. 性能限制：如之前提到的，`localStorage`  的操作是阻塞的。如果网站能够存储大量数据，就会加剧读写操作对页面性能的影响。
4. 存储效率：`localStorage`  存储的是字符串形式的数据，不是为存储大量或结构化数据设计的。当尝试存储过多数据时，效率会降低。
5. 历史和兼容性：5MB 的限制很早就已经被大多数浏览器实现，并被作为一个非正式的标准被采纳。尽管现在有些浏览器支持更大的  `localStorage`，但出于跨浏览器兼容性的考虑，开发者通常会假设这个限制。
6. 浏览器政策：浏览器厂商可能会依据自己的政策来设定限制，可能是出于提供用户更一致体验的角度，或者是出于管理用户数据的方便。

## IndexedDB

虽然它们提供了更大的存储空间和更丰富的功能，但确实潜在地也可能被滥用。但是与相比 `localStorage` 增加了一些特性用来降低被滥用的风险：

1. **异步操作：**`IndexedDB` 是一个异步API，即使它被用来处理更大量的数据，也不会像 `localStorage` 那样阻塞主线程，从而避免了对页面响应性的直接影响。
2. **用户提示和权限：**对于某些浏览器，当网站尝试存储大量数据时，浏览器可能会弹出提示，要求用户授权。这意味着用户有机会拒绝超出合理范围的存储请求。
3. **存储配额和限制：**尽管 `IndexedDB` 提供的存储容量比 `localStorage` 大得多，但它也不是无限的。浏览器会为 `IndexedDB` 设定一定的存储配额，这个配额可能基于可用磁盘空间的一个百分比或者是一个事先设定的限额。配额超出时，浏览器会拒绝更多的存储请求。
4. **更清晰的存储管理：**`IndexedDB` 的数据库形式允许有组织的存储和更容易的数据管理。用户或开发者可以更容易地查看和清理占用的数据。
5. **逐渐增加的存储：**某些浏览器实现 IndexedDB 存储时，可能会在数据库大小增长到一定阈值时，提示用户是否允许继续存储，而不是一开始就分配一个很大的空间。

# 其他使用场景

## 缓存数据

没错，还是存储数据，但是带了一些业务逻辑。

1. 存储用户信息，下一次直接从缓存中读取。至于登录态，可以从下一个请求中识别。但需要注意如何区分登录用户是否换了。
2. 存储页面初始化所需的数据。首屏直接展示历史数据，然后再发起请求获取最新数据。
3. 用户设置的某些状态（如果可以）。

总的来说，缓存数据可以有效提高应用程序的性能、用户体验，并降低网络成本，是Web开发中常用的优化手段之一。

## 多页面通信

通过监听`localStorage`可以实现页面间通信的能力。当一个页面修改了`localStorage`中的数据时，其他页面可以通过监听`storage`事件来获取到这些变化，从而实现页面间通信。

```js
// 在接收数据的页面中添加storage事件监听器
window.addEventListener('storage', function(event) {
    if (event.key === 'myData') {
        console.log('接收到数据变化：', event.newValue);
        // 在这里处理接收到的数据
    }
});
```

在发送数据的页面中，你可以通过`localStorage.setItem(key, value)`方法来修改`localStorage`中的数据。这样，当数据被修改时，其他页面就能通过监听`storage`事件来获取到最新的数据，实现页面间通信。

需要注意的是，`storage`事件是基于同源策略的，只有在相同域名下的页面之间才能进行通信。

该功能适合可能会在多个页面打开的应用，例如协同文档，多个页面间有相同业务的数据时，一个页面的变更可以直接本地同步到其他页面；如果页面有轮询的请求，只需确认一个主体页面发起请求，其他页面只需同步即可。

当然，其他一些方式也可以实现多页面通信，如`BroadcastChannel`、`localstorage-event`等。

# 参考文档

- [【前端缓存】localStorage 是同步还是异步的？为什么？
  ](https://juejin.cn/post/7359405716090011659?utm_source=gold_browser_extension)
- GPT问答
